import fs from 'node:fs/promises';
import fs1 from 'node:fs';
import type { ModuleNode, ViteDevServer } from 'vite';
import {
    createHtmlTag,
    createLinkHeader,
    Preload,
    sortPreloadModules,
} from './utils';
import React from 'react';
import debug from 'debug';
import { ModuleCollectorContext } from './context';

const log = debug('vite-preload');

interface Chunk {
    src: string;
    name: string;
    file: string;
    isEntry?: boolean;
    imports?: string[];
    dynamicImports?: string[];
    css?: string[];
    assets?: string[];
}

type Manifest = Record<string, Chunk>;

interface ModuleCollectorOptions {
    /**
     * The manifest.json, NOT ssr-manifest.json as it does not include dynamic imports!
     *
     * Optional, not used in dev
     */
    manifest?: Manifest;

    /**
     * The client entrypoint for your vite application.
     *
     * Defaults to `index.html`
     */
    entrypoint?: string;
}

export class ChunkCollector {
    /**
     * Detected module IDs
     */
    modulesIds = new Set<string>();

    constructor(private options: ModuleCollectorOptions = {}) {
        this.__context_collectModuleId = this.__context_collectModuleId.bind(this);
        this.getModules = this.getModules.bind(this);
        this.getTags = this.getTags.bind(this);
        this.getLinkHeader = this.getLinkHeader.bind(this);
        // this.getPreloadStuff = this.getPreloadStuff.bind(this);
    }

    /**
     * Function is called by `ChunkCollectorContext`
     */
    __context_collectModuleId(moduleId: string) {
        this.modulesIds.add(moduleId);
    }

    getModules() {
        const map = new Map<string, Preload>();
        for (const moduleId of this.modulesIds) {
            collectModules(moduleId, this.options, map);
        }

        return sortPreloadModules(Array.from(map.values()));
    }

    /**
     * Returns all HTML tags for preload hints and stylesheets.
     *
     * If `includeEntrypoint` is set, entry <script module> and CSS will be included.
     * If not, it's assumed that you use the template html generated by Vite in `options.entrypoint`, that already includes the entrypoint tags.
     */
    getTags(includeEntrypoint?: boolean): string {
        const modules = this.getModules();

        return modules
            .filter((m) => includeEntrypoint || !m.isEntry)
            .map(createHtmlTag)
            .filter(Boolean)
            .join('\n');
    }

    /**
     * Returns a `Link` header with all chunks to preload,
     * including entry chunks.
     */
    getLinkHeader(): string {
        const modules = this.getModules();
        return createLinkHeader(modules);
    }
}

/**
 * React context to collect used modules
 *
 * Usage:
 *
 * ```
 * const manifest = fs.readFile('.vite/dist', 'utf8');
 * const collector = new ChunkCollector({ manifest });
 *
 * render(
 *  <ChunkCollectorContext collector={collector}>
 *      <App />
 *  </ChunkCollectorContext>
 * )
 * ```
 */
export function ChunkCollectorContext({
    collector,
    children,
}: {
    collector: ChunkCollector;
    children: any;
}) {
    // React 19 support
    const ContextComponent =
        'Provider' in ModuleCollectorContext
            ? ModuleCollectorContext.Provider
            : ModuleCollectorContext;

    return React.createElement(
        ContextComponent,
        {
            value: collector.__context_collectModuleId,
        },
        children
    );
}

/*
  url: '/src/pages/Browse/index.ts',
  id: '/<absolute>/src/pages/Browse/index.ts',
  file: '/<absolute>/src/pages/Browse/index.ts',
*/
/**
 * https://vitejs.dev/guide/backend-integration
 * https://github.com/vitejs/vite-plugin-react/tree/main/packages/plugin-react#consistent-components-exports
 * https://github.com/vitejs/vite-plugin-vue/blob/main/playground/ssr-vue/src/entry-server.js
 */

/**
 * This function figures out what modules are used based on the modules rendered by React.
 *
 * It follows https://vitejs.dev/guide/backend-integration
 */
function collectModules(
    moduleId: string,
    { manifest, entrypoint = 'index.html' }: ModuleCollectorOptions,
    assets = new Map<string, Preload>()
) {
    const vite: ViteDevServer = globalThis.vite;

    if (vite) {
        return new Map();
        let m: ModuleNode;

        const urls = {};

        const i1 = vite.moduleGraph.idToModuleMap.get(moduleId);
        const i2 = vite.moduleGraph.urlToModuleMap.get(moduleId);

        console.log('i1', i1);
        console.log('i2', i2);

        // const first = await vite.moduleGraph.getModuleByUrl(moduleId);
        // console.log('first', first);
        // await recursive(urls, first);
        // console.log('id', urls);

        const tags = [];
        // Object.values(urls).forEach(v => {
        //   tags.push(getTag(v));
        // });
        return [];
    } else {
        if (!manifest) {
            throw new Error(
                'No manifest.json provided. Set build.manifest to true in your vite config.'
            );
        }


        const chunkId = moduleId.startsWith('/')
            ? moduleId.substring(1)
            : moduleId;

        // The reported module ID is not in it's own chunk
        if (!manifest[chunkId]) {
            return assets;   
        }

        const chunks = new Map<string, Chunk>();

        const entryChunk = manifest[entrypoint];
        if (!entryChunk) {
            throw new Error(
                `Entrypoint "${entrypoint}" not found in manifest.json`
            );
        }

        if (!entryChunk.isEntry) {
            throw new Error(
                `Specified entrypoint ${entrypoint} is not an entry module`
            );
        }

        collectChunksFromManifest(manifest, entrypoint, chunks);
        collectChunksFromManifest(manifest, chunkId, chunks);

        for (const chunk of chunks.values()) {
            if (assets.has(chunk.file)) {
                continue;
            }

            for (const cssFile of chunk.css || []) {
                if (assets.has(cssFile)) continue;
                assets.set(cssFile, {
                    rel: 'stylesheet',
                    href: cssFile,
                    comment: `chunk: ${chunk.name}, isEntry: ${chunk.isEntry}`,
                    isEntry: chunk.isEntry,
                });
            }

            for (const asset of chunk.assets || []) {
                if (assets.has(asset)) continue;
                assets.set(asset, {
                    rel: 'preload',
                    href: `/${asset}`,
                    comment: `Asset from chunk ${chunk.name}: ${chunk.file}`,
                });
            }

            // Only the entrypoint module is used as a module, everything else is modulepreload
            const isPrimaryModule = chunk.src === entrypoint;
            assets.set(chunk.file, {
                rel: isPrimaryModule ? 'module' : 'modulepreload',
                href: chunk.file,
                comment: `chunk: ${chunk.name}, isEntry: ${chunk.isEntry}`,
                isEntry: chunk.isEntry,
            });
        }

        return assets;
    }
}

function collectChunksFromManifest(
    manifest: Manifest,
    chunkId: string,
    chunks = new Map<string, Chunk>(),
    isEntry?: boolean
): Map<string, Chunk> {
    const chunk = manifest[chunkId];

    if (!chunk) {
        throw new Error(`Missing chunk '${chunkId}'`);
    }

    if (chunks.has(chunkId)) {
        return chunks;
    }

    chunks.set(chunkId, { ...chunk, isEntry: isEntry || chunk.isEntry });

    for (const importName of chunk.imports || []) {
        collectChunksFromManifest(
            manifest,
            importName,
            chunks,
            isEntry || chunk.isEntry
        );
    }

    return chunks;
}

function collectChunksFromModuleGraph() {}
